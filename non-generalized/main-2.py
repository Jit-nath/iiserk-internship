import argparse
import logging
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Optional

import numpy as np

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
logger = logging.getLogger(__name__)

@dataclass(order=True)
class Atom:
    sort_index: int = field(init=False, repr=False)
    atomID: int
    atomName: str
    residueName: str
    resID: int
    coords: np.ndarray  # shape (3,)
    occupancy: float
    tempFactor: float
    chainID: str

    def __post_init__(self):
        # For ordering by atomID by default
        self.sort_index = self.atomID

    @property
    def x(self) -> float:
        return float(self.coords[0])

    @property
    def y(self) -> float:
        return float(self.coords[1])

    @property
    def z(self) -> float:
        return float(self.coords[2])

    def translate(self, vector: np.ndarray) -> None:
        self.coords += vector

    def copy(self) -> 'Atom':
        return Atom(
            atomID=self.atomID,
            atomName=self.atomName,
            residueName=self.residueName,
            resID=self.resID,
            coords=self.coords.copy(),
            occupancy=self.occupancy,
            tempFactor=self.tempFactor,
            chainID=self.chainID
        )


def read_pdb_file(filepath: Path) -> List[Atom]:
    atoms: List[Atom] = []
    if not filepath.exists():
        logger.error("PDB file not found: %s", filepath)
        return atoms

    with filepath.open('r') as f:
        for line in f:
            if not line.startswith('ATOM'):  # |HETATM|
                continue
            try:
                atom_id = int(line[6:11])
                atom_name = line[12:16].strip()
                residue_name = line[17:20].strip()
                res_id = int(line[22:26])
                coords = np.array([
                    float(line[30:38]),
                    float(line[38:46]),
                    float(line[46:54])
                ], dtype=float)
                occupancy = float(line[54:60])
                temp_factor = float(line[60:66])
                chain_id = line[72:76].strip()

                atoms.append(Atom(
                    atomID=atom_id,
                    atomName=atom_name,
                    residueName=residue_name,
                    resID=res_id,
                    coords=coords,
                    occupancy=occupancy,
                    tempFactor=temp_factor,
                    chainID=chain_id
                ))
            except ValueError as e:
                logger.warning("Skipping malformed ATOM line: %s (%s)", line.strip(), e)
    logger.info("Loaded %d atoms from %s", len(atoms), filepath)
    return atoms


def write_pdb_file(filepath: Path, atoms: List[Atom], title: Optional[str] = None) -> None:
    with filepath.open('w') as f:
        # Header
        f.write("CRYST1    0.000    0.000    0.000  90.00  90.00  90.00 P 1           1\n")
        f.write("REMARK Generated by lipid repositioning tool\n")
        if title:
            f.write(f"REMARK {title}\n")

        for atom in sorted(atoms):
            x, y, z = atom.coords
            f.write(
                f"ATOM  {atom.atomID:5d} {atom.atomName:>4} {atom.residueName:>3} "
                f"{atom.chainID:1}{atom.resID:4d}    {x:8.3f}{y:8.3f}{z:8.3f}"
                f"{atom.occupancy:6.2f}{atom.tempFactor:6.2f}      {atom.chainID}\n"
            )
        f.write("END\n")
    logger.info("Wrote %d atoms to %s", len(atoms), filepath)


def find_root_atom(atoms: List[Atom]) -> Atom:
    for pref in ('N', 'P'):
        for atom in atoms:
            if atom.atomName.startswith(pref):
                logger.debug("Selected root atom: %s", atom.atomName)
                return atom
    logger.debug("No N/P atoms found; defaulting to first atom")
    return atoms[0]


def calculate_direction(atoms: List[Atom], root: Atom, num_tails: int = 2) -> np.ndarray:
    # Compute distances
    distances = [(np.linalg.norm(atom.coords - root.coords), atom) for atom in atoms]
    distances.sort(key=lambda x: x[0], reverse=True)
    tails = [atom for _, atom in distances[:num_tails]]
    if not tails:
        return np.array([0.0, 0.0, 1.0])
    vecs = [tail.coords - root.coords for tail in tails]
    avg = np.mean(vecs, axis=0)
    return avg / np.linalg.norm(avg)


def create_rotation_matrix(from_vec: np.ndarray, to_vec: np.ndarray) -> np.ndarray:
    # Normalize
    a = from_vec / np.linalg.norm(from_vec)
    b = to_vec / np.linalg.norm(to_vec)
    v = np.cross(a, b)
    c = np.dot(a, b)
    if np.isclose(c, 1.0):
        return np.eye(3)
    if np.isclose(c, -1.0):
        # 180-degree rotation
        perp = np.array([1, 0, 0]) if abs(a[0]) < 0.9 else np.array([0, 1, 0])
        axis = np.cross(a, perp)
        axis /= np.linalg.norm(axis)
        return 2.0 * np.outer(axis, axis) - np.eye(3)
    kmat = np.array([[   0, -v[2],  v[1]],
                     [ v[2],    0, -v[0]],
                     [-v[1], v[0],    0]])
    return np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (np.linalg.norm(v) ** 2))


def reposition_atoms(atoms: List[Atom], root: Atom, new_direction: np.ndarray) -> List[Atom]:
    orig_dir = calculate_direction(atoms, root)
    R = create_rotation_matrix(orig_dir, new_direction)
    result: List[Atom] = []
    for atom in atoms:
        atom_copy = atom.copy()
        # translate to origin, rotate, translate back
        atom_copy.coords = R.dot(atom_copy.coords - root.coords) + root.coords
        result.append(atom_copy)
    return result


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Reposition lipid PDB atoms along a new direction"
    )
    parser.add_argument("--input", type=Path, required=True, help="Input PDB file")
    parser.add_argument("--output", type=Path, required=True, help="Output PDB file")
    parser.add_argument(
        "--dir", type=float, nargs=3, metavar=("DX", "DY", "DZ"),
        default=[1.0, 0.0, 0.0],
        help="New direction vector (default: [1,0,0])"
    )
    return parser.parse_args()


def main():
    args = parse_args()
    atoms = read_pdb_file(args.input)
    if not atoms:
        logger.error("No atoms to process. Exiting.")
        return

    root = find_root_atom(atoms)
    new_dir = np.array(args.dir, dtype=float)
    new_dir /= np.linalg.norm(new_dir)

    repositioned = reposition_atoms(atoms, root, new_dir)
    write_pdb_file(args.output, repositioned, title=f"Directed along {new_dir.tolist()}")

if __name__ == "__main__":
    main()
